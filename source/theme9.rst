========================================================
Введение в ООП. Настройка окружения и установка пакетов
========================================================

`Лекция в .ipynb формате <../../source/lectures/theme9.ipynb>`_

Установка пакетов и настройка окружения в Python
================================================

``pip`` и ``conda``
-------------------

Сторонние библиотеки можно устанавливать различными методами. Глобально
их можно разделить на два основных: ручная установка и менеджеры
пакетов. В большинстве случаев предпочтительно использовать именно
менеджеры пакетов, т.к. они способны автоматически разрешить большую
часть зависимостей. Здесь мы рассмотрим два наиболее актуальных для
наших задач: стандартный ``pip`` (в ходит в дистрибутив python по
умолчанию) и менеджер пакетов от anaconda.

Для использования ``pip`` достаточно запустить командную строку с каким
либо активированным окружением и ввести команду

::

   pip install package_name

На пример, для установки numpy строка будет выглядеть
``pip install numpy``.

Аналогичная ситуация с anaconda: ``conda install numpy``.

Также большинство пакетов в своей документации приводят конкретную
строку для установки (иногда требуется передать в установщик
дополнительные параметры, такие как версия или источник).

Настройка окружения в Python
----------------------------

Интерпретатор, запуская любой скрип, пытается выполнить его в
основываясь на заданных настройках. Заметная часть этих настроек
включает в себя какие именно пакеты и где ему искать. В ОС существует
глобальное окружение с заданными параметрами (например язык, время и
т.д.) и стандартные пути для поиска пакетов и библиотек. Иногда, вам
может потребоваться задать эти параметры отличные от системных настроек.
Такая ситуация может произойти при работе на сторонних серверах, где у
пользователя недостаточно прав для установки пакетов в системные
директории, или же при сборке проекта (например Pyinstaller при
использовании со стандартной средой anaconda может раздуть финальный
проект до нескольких гигабайт просто пытаясь впихнуть в него все
возможные зависимости). Для этого можно использовать настройки
виртуального окружения, которые стандартно управляются утилитой ``venv``
`(смотри документацию) <https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment>`_.

В случае использования Anaconda-Navigator управление пакетами и
виртуальной средой можно делать графически на вкладке Environments.

Основы ООП
==========

Согласно `Википедии <https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование>`_, **Объе́ктно-ориенти́рованное программи́рование (ООП)**
- — методология программирования, основанная на представлении программы
в виде совокупности объектов, каждый из которых является экземпляром
определённого класса, а классы образуют иерархию наследования.

Основные принципы структурирования в случае ООП связаны с различными
аспектами базового понимания предметной задачи, которое требуется для
оптимального управления соответствующей моделью:

-  **абстракция** для выделения в моделируемом предмете важного для
   решения конкретной задачи по предмету, в конечном счёте — контекстное
   понимание предмета, формализуемое в виде **класса**;

-  **инкапсуляция** для быстрой и безопасной организации собственно
   иерархической управляемости: чтобы было достаточно простой команды
   **«что делать», без одновременного уточнения как именно делать**, так
   как это уже другой уровень управления;

-  **наследование для быстрой** и безопасной организации родственных
   понятий: чтобы было достаточно на каждом иерархическом шаге учитывать
   только изменения, не дублируя всё остальное, учтённое на предыдущих
   шагах;

-  **полиморфизм** для определения точки, в которой единое управление
   лучше распараллелить или наоборот — собрать воедино.

В данной лекции будут затронуты лишь базовые понятия ООП в Python,
достаточные для дальнейшего углубления в тему, и поверхностного
самостоятельного понимания сторонних модулей.

Зачем это надо?
---------------

-  Язык Python базируется на концепции ООП. Большая часть
   специализированного применения также подразумевает ООП. Часто,
   документацией к некоторым пакетам является просто исходный код с
   комментариями.
-  Можно писать свои небольшие пакеты, удобные для стороннего
   использования (или для самостоятельного использования, но позже). Нет
   необходимости разбираться сколько и каких аргументов требуется
   передать. Все можно заранее предусмотреть в самом классе, и не
   тратить время на воспоминания о том что именно и как делает этот код.
-  Удобно для написания собственных рутинных “оболочек” для сторонних
   пакетов (например для matplotlib).

Классы в Python
---------------

Python является объектно-ориентированным языком. Каждый используемый
элемент (даже числа) в нем является объектом с теми или иными заданными
методами.

Создание класса происходит простым способом:

.. code:: ipython3

    class ClassName(object):
      # методы и атрибуты класса ClassName

.. note:: 

    По общей договоренности название классов пишется слитно с заглавных букв, а функций, методов и констат с маленьких разделителем "_".

Создадим наш новый класс для описания атомов:

.. code:: ipython3

    class Atom(object):
        element = 'C'
        def set_coord(self, coords):
            self.x, self.y, self.z = coords # меняем атрибуты класса
    
    
    a1=Atom() # создаем объект класса Atom
    
    print(type(a1))
    print(a1.element) #выводим заданные атрибуты класса
    
    a1.set_coord([1,2,3])   # используем метод класса
    print(a1.x, a1.y, a1.z) # выводим новые атрибуты класса
    
    a1.element = 'H'
    a1.mass = 1.00784       # добавляем или изменяем атрибут или метод
    print(a1.element, a1.mass)


.. parsed-literal::

    <class '__main__.Atom'>
    C
    1 2 3
    H 1.00784


Для наследования свойств класса, родительские классы достаточно указать
в скобках при описании дочернего класса. При этом атрибуты и методы
родительского могут быть вызванны и/или переопределенны из дочернего.

.. code:: ipython3

    class DummyAtom(Atom):
        element = None
    
    da1 = DummyAtom()
    print(da1.element)
    
    da1.set_coord([1,2,3])   # используем метод родительского класса
    print(da1.x, da1.y, da1.z)


.. parsed-literal::

    None
    1 2 3


Специальные (магические) методы
-------------------------------

Для того чтобы узнать какие у класса есть методы и атрибуты существует
стандартная функция ``dir()``

.. code:: ipython3

    print(dir(Atom))


.. parsed-literal::

    ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'element', 'set_coord']


Последние два создали мы, остальные являются специальными методами
класса. По аналогии с функцией dir() вам могут быть полезны следующие
методы (в Python классы тоже являются объектами):

.. code:: ipython3

    print(a1.__dict__)    # словарь всех публичных атрибутов объекта
    print(a1.__dir__())   # тоже что и dir для класса, только для объекта


.. parsed-literal::

    {'x': 1, 'y': 2, 'z': 3, 'element': 'H', 'mass': 1.00784}
    ['x', 'y', 'z', 'element', 'mass', '__module__', 'set_coord', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']


Инициализация объекта
---------------------

Для выполнения какой-то логики для объекта при его иницилизации
используется метод ``__init__``. Перезададим наш класс ``Atom``

.. code:: ipython3

    import numpy as np
    
    class Atom(object):
        def set_coord(self, coords):
            self.x, self.y, self.z = coords # меняем атрибуты класса
        
        _massDict={'H':1.00784,  # не публичные атрибуьы начинаются с _
                   'O':15.999,   # к ним можно получить доступ,
                   'C':12.0107,  # но в чужом коде их лучше не трогать
                   'N':14.0067}
        
        def __init__(self, element, coords):
            self.element=element
            self.mass = self._massDict[element]
            self.set_coord(coords)
            self.coords=np.array(coords)
    
    a1=Atom('H',[1,2,3])
    print(a1.__dict__)


.. parsed-literal::

    {'element': 'H', 'mass': 1.00784, 'x': 1, 'y': 2, 'z': 3, 'coords': array([1, 2, 3])}


Итерация по объекту
-------------------

Создадим новый класс Molecule. И сделаем так, чтобы мы могли итерировать
молекулу по атомам. Для этого определим следующие методы (на деле их
больше, см. сontainer special methods):

-  ``__len__(self)`` - возвращаем значения для функции ``len``

-  ``__getitem__(self, key)`` - Определяет поведение при доступе к
   элементу, используя синтаксис ``self[key]``.

-  ``__iter__(self)`` - Должен вернуть итератор для контейнера. Проще
   всего с помощью встроенной функции ``iiter(self.some_list)``

.. code:: ipython3

    class Molecule:
        def __init__(self, list_of_atoms=None):
            if list_of_atoms: 
                self.list_of_atoms = list_of_atoms
            else: self.list_of_atoms = []
                
        def __len__(self):
            return len(self.list_of_atoms)
        
        def __getitem__(self, element):
            "возвращаем список всех атомов заданного типа"
            list_to_return=[]
            for atom in self.list_of_atoms:
                if atom.element==element:
                    list_to_return.append(atom)
            return list_to_return
        
        def __iter__(self):
            return iter(self.list_of_atoms)
        
        def add_atom(self, atom):
            self.list_of_atoms.append(atom)
        
        # а не посчитать ли нам центр масс и молярную массу?
        def molar_mass(self):
            molar=0
            for atom in self.list_of_atoms:
                molar+= atom.mass
            return molar
        
        def center_of_mass(self):
            CoM=np.array([0., 0., 0.])
            for atom in self.list_of_atoms:
                CoM+= atom.mass*atom.coords
            return CoM/self.molar_mass()
            
    m1=Molecule() #создаем пустую молекулу
    
    water = [['O',  0.000, 0.000, 0.0],
             ['H',  0.757, 0.586, 0.0],
             ['H', -0.757, 0.586, 0.0]]
    
    for a in water:
        m1.add_atom(Atom(a[0], a[1:]))  #заполняем молекулу атомами
    
    print(len(m1))
    
    for atom in m1:
        print(atom.element, atom.x, atom.y,  atom.z)
    
    print(m1['H'])
    
    print(m1.molar_mass())
    print(m1.center_of_mass())


.. parsed-literal::

    3
    O 0.0 0.0 0.0
    H 0.757 0.586 0.0
    H -0.757 0.586 0.0
    [<__main__.Atom object at 0x7f267b4adc70>, <__main__.Atom object at 0x7f267b4ad370>]
    18.014680000000002
    [0.         0.06556811 0.        ]


Определение арифметических и логических операций
------------------------------------------------

Отношение к арифметическим операциям также можно определять спеуиальными
методами. Несколько примеров (далеко не все) приведенны ниже: \*
``__add__(self, other)`` - Сложение. \* ``__sub__(self, other)`` -
Вычитание. \* ``__mul__(self, other)`` - Умножение. \*
``__div__(self, other)`` - Деление, оператор /.

Для логических операций можно также определить исход сравнения:

-  ``__eq__(self, other)`` определяет поведение оператора ``==``
-  ``__ne__(self, other)`` определяет поведение оператора ``!=``
-  ``__lt__(self, other)`` определяет поведение оператора ``<``
-  ``__gt__(self, other)`` определяет поведение оператора ``>``
-  ``__le__(self, other)`` определяет поведение оператора ``<=``
-  ``__ge__(self, other)`` определяет поведение оператора ``>=``

Модернизируем наш класс ``Atoms``, чтобы при сложении возвращало
молекулу, а сравнение происходило основываясь на массах атомов.

.. code:: ipython3

    class Atom(object):
        def set_coord(self, coords):
            self.x, self.y, self.z = coords # меняем атрибуты класса
        
        _massDict={'H':1.00784,  # не публичные атрибуьы начинаются с _
                   'O':15.999,   # к ним можно получить доступ,
                   'C':12.0107,  # но в чужом коде их лучше не трогать
                   'N':14.0067}
        
        def __init__(self, element, coords):
            self.element=element
            self.mass = self._massDict[element]
            self.set_coord(coords)
            self.coords=np.array(coords)
            
        def __add__(self, at2):
            return Molecule([self, at2])
        
        def __eq__(self, at2):
            return (self.mass==at2.mass)
        
        def __lt__(self, at2):
            return (self.mass<at2.mass)
        #остальные операции сравнения по аналогии
        
    h=Atom('H',[0,0,0])
    h_=Atom('H',[1,0,0])
    H2 = h+h_
    print(type(H2))
    print(h<h_)


.. parsed-literal::

    <class '__main__.Molecule'>
    False


Большой пример.
===============

Попробуем что-нибудь порисовать. Для работы с простейшими графическими
приложениями нам потребуется модуль ``tkinter``. Для работы со временем
библиотека ``time``.

.. code:: ipython3

    import tkinter as tk
    import time
    
    gui = tk.Tk()      # инициализируем модуль
    gui.geometry("800x600")   #создаем пустое окно
    gui.title("окошко")
    
    #инструмент для рисования
    canvas = tk.Canvas(gui, width=800,height=600,bg='white') 
    canvas.pack()
    #рисуем линию
    canvas.create_line(0, 300, 150, 150, width=10, fill='green')
    # рисуем квадратик
    rect = canvas.create_rectangle(300,100, 400, 200, fill='#0000ff')
    #рисуем шарик
    ball1 = canvas.create_oval(100,100,150,150, width=2, fill='#ff0000')
    
    
    #задаем смещение круга за шаг
    xa=2
    ya=5
    
    while True:
        #смещаем позицию круга
        canvas.move(ball1,xa,ya)
        pos=canvas.coords(ball1)
    
        # отражаем от стен
        if pos[3] >=600 or pos[1] <=0:
            ya = -ya
        if pos[2] >=800 or pos[0] <=0:
            xa = -xa
     
        # обновляем состояние окна
        gui.update()
        time.sleep(.025)

создадим объект который будет обновляться по своим правилам

.. code:: ipython3

    import numpy as np
    
    
    class Ball(object):
        def __init__(self, canvas):
            x = np.random.randint(0, 800)
            y = np.random.randint(0, 600)
            self.x_priv = x - np.random.randint(-5, 5)
            self.y_priv = y - np.random.randint(-5, 5)
            self.canvas = canvas
            self.icanv = self.canvas.create_oval(x, y, x + 10, y + 10, 
                                                 width=2, fill='blue')
            pos = canvas.coords(self.icanv)
            self.x = (pos[0] + pos[2]) / 2
            self.y = (pos[1] + pos[3]) / 2
    
        def _a(self):
    
    
            m = 2
            return [0, 10 / m]
    
        def move(self):
            'используем алгоритм Верле'
            dt = 0.1
            ax, ay = self._a()
    
            dx = self.x - self.x_priv + ax * dt ** 2
            dy = self.y - self.y_priv + ay * dt ** 2
            #отражаем от стен или просто обновляем
            if self.x + dx > 790 or self.x + dx<10:
                self.x_priv = self.x
                self.x -= dx
            else:
                self.x_priv = self.x
                self.x += dx
    
            if self.y + dy > 590 or self.y + dy<10:
                self.y_priv = self.y
                self.y -= dy
            else:
                self.y_priv = self.y
                self.y += dy
    
            # смещаем позицию круга
            self.canvas.move(self.icanv, dx, dy)

Запускаем наш код заново

.. code:: ipython3

    import tkinter as tk
    import time
    gui = tk.Tk()      # инициализируем модуль
    gui.geometry("800x600")   #создаем пустое окно
    gui.title("окошко")
    
    #инструмент для рисования
    canvas = tk.Canvas(gui, width=800,height=600,bg='white')
    canvas.pack()
    
    #создаем объект
    ball1 = Ball(canvas)
    ball2 = Ball(canvas)
    
    while True:
        ball1.move()
        ball2.move()
        gui.update()
        time.sleep(.025)

Попробуем создать более физичный “шарик”. Будем считать что все шарики
взаимодействют друг с дркгом согласно потенциалу Леннарда-Джонса:
:math:`U_{LJ} = 4\varepsilon \left[ \left(\frac{\sigma}{r}\right)^{12}-\left(\frac{\sigma}{r}\right)^6 \right]`.

Помимо этого, обновим граничные условия (по мере приближения к границы
энергия шарика начне расти квадратично), и добавим специальную окраску
шарикам.

.. note:: 
    такая модель применяется для моделирования идеальных газов методом молекулярной динамики. Стоит отметить, что конкретно *этот пример крайне слабо связан с реальными алгоритмами МД*, в виду абсолютно неразумного расходования вычислительных ресурсов, а призван лишь продемонстрировать пример ООП.

.. code:: ipython3

    import numpy as np
    
    class Ball(object):
        
        def __init__(self, canvas,x,y):
            #начальное состояние
            v0=2
            self.x_priv = x+(np.random.rand()-0.5)*v0
            self.y_priv = y+(np.random.rand()-0.5)*v0
            #добавляем картинку
            self.canvas = canvas
            self.icanv = self.canvas.create_oval(x, y, x + 10, y + 10, 
                                                 width=2, fill='#ffffff')
            pos = canvas.coords(self.icanv)
            self.x = x
            self.y = y
            # список соседей
            self.neighb=[]
    
        def _U(self,x,y):
            #параметры потенциала
            E=4
            sigma=20
            
            U=0.
            # отражаем от границ
            if x>750: U+=(x-750)**4
            if x<50: U+=(50-x)**4
            if y>550: U+=(y-550)**4
            if y<50: U+=(50-y)**4
                
            #считаем потенциальную энергию
            for a in self.neighb:
                r = ((a.x - x) ** 2 + (a.y - y) ** 2) ** 0.5
                U+=4*E*((sigma/r)**12-(sigma/r)**6)
            return U
    
        def calc_a(self):
            "считаем ускорение как градиент силы"
            m = 1
            dr=0.0001
            self.U0=self._U(self.x,self.y)
            Fx = -(self._U(self.x + dr, self.y) - self.U0) / dr
            Fy = -(self._U(self.x, self.y + dr) - self.U0) / dr
            self.a=[Fx/m,Fy/m]
    
        def update_color(self):
            bs=255/90
            rs=255/1000
            if self.U0<=0:
                if self.U0<-90:color='#0000ff'
                else:color='#{:02x}{:02x}ff'.format(255+int(bs*self.U0), 
                                                    255+int(bs*self.U0))
            if self.U0>0:
                if self.U0>1000:color='#ff0000'
                else:color='#ff{:02x}{:02x}'.format(255-int(rs*self.U0),
                                                    255-int(rs*self.U0))
            self.canvas.itemconfig(self.icanv, fill=color)
    
        def recalc_neighb(self, all_list):
            "просто перебираем все шарики"
            for a in all_list:
                r=((a.x-self.x)**2+(a.y-self.y)**2)**0.5
                if r<40 and self.icanv!=a.icanv: self.neighb.append(a)
    
        def move(self):
            'используем алгоритм Верле'
            dt = 0.01
            ax, ay = self.a
            dx = self.x - self.x_priv + ax * dt ** 2
            dy = self.y - self.y_priv + ay * dt ** 2
    
            # немного остужаем систему на каждом шаге
            dx*=0.99999
            dy*=0.99999
    
            self.x_priv = self.x
            self.y_priv = self.y
    
            self.x += dx
            self.y += dy
    
            # смещаем позицию круга
            self.canvas.move(self.icanv, dx, dy)

Запустим также немного модернизированное окошко с шариками

.. code:: ipython3
 
    import tkinter as tk
    import time
    gui = tk.Tk()      # инициализируем модуль
    gui.geometry("800x600")   #создаем пустое окно
    gui.title("окошко")
    
    #инструмент для рисования
    canvas = tk.Canvas(gui, width=800,height=600,bg='white')
    canvas.pack()
    
    list_of_balls=[]
    
    #создаем объект и задаем начальные координаты, исключающие пересечения
    cl=list(range(35*25))
    for i in range(50):
        c=np.random.choice(cl)
        x=c//25
        y=c%25
        cl.remove(c)
        list_of_balls.append(Ball(canvas,x*20+50,y*20+50))
    
    
    i=0
    while True:
        for ball in list_of_balls:
            
            # для хоть какой-то экономии ресурсов 
            # пересчитываем соседей не каждый шаг
            if i%4==0:  
                ball.recalc_neighb(list_of_balls)
            ball.calc_a() #считаем ускорения
            
        for ball in list_of_balls:
            ball.update_color() #обновляем цвет и двигаем
            ball.move()
        gui.update()
        time.sleep(0.001)
        i+=1

Задачи
======

1. На основе класса ``matplotlib.axes`` (`описание класса <https://matplotlib.org/3.3.3/api/axes_api.html>`_) и других
   необходимых стороних библиотек и функций, создайте дочерний класс,
   который бы умел чиать csv файлы (``numpy.loadtxt``), и автоматически
   строил линеаризацию данных (см. первый пример в теме *Библиотека
   SciPy*). Добавьте автоматический вывод уравнения прямой на график, и
   задайте новый стандартный формат маркеров и линий (например красные
   ромбики и синий пунктир, или что-либо еще на ваше усмотрение).
   Проверьте корректность вывода на каком нибудь примере (т.е. создайте
   файл с зашумленной линией, сохраните его, а потом постройте данные с
   помощью вашего нового класса)

2. Смоделируйте поведение 1D системы из :math:`N` шариков разной массы,
   последовательно связанных друг с другом пружинками разной жесткости.
   Изменением цвета пружинки (линии) отображайте ее напряжение
   :math:`\frac{k \Delta x^2}{2}`. Крайний шарик превратите в стенку, не
   переписывая весь класс, а лишь изменив необходимые методы или
   аттрибуты конкретного объекта.
