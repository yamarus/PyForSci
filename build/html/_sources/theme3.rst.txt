.. _theme3:
  
=========================================
Числа и списки
=========================================
`Лекция в .ipynb формате <../../source/lectures/theme3.ipynb>`_

Числа
=======
В python существует три стандартных класса чисел: цлочисленные (int), числа с плавающей запятой (float) и комплексные числа (complex). Подробное описание спецификаций численных типов Python можно найти в `описании типов <https://docs.python.org/3.8/library/stdtypes.html?#numeric-types-int-float-complex>`_. 

Общие операции ``+`` (сложение), ``-`` (вычитание), ``*`` (умножение), ``/`` (деление), ``**`` (степень).

.. code:: python

    print(2+3)
    print(3/2)
    print(9**0.5)
    print(0**0)


.. parsed-literal::

    5
    1.5
    3.0
    1

При использовании арифметических операций необходимо помнить про их приоритет: ``**`` > ``*``, ``/`` (равный приоритет) > ``+``, ``-`` (равный приоритет). Лучше использовать скобки для явного указания приоритета (явное лучше неявного). В противном случае можно столкнуться с "неожиданным" поведением:

.. code:: python

    print(9**1/2)


.. parsed-literal::

    4.5


Целые числа (int)
-----------------

``x//y`` - целочисленное деление (округление в сторону :math:`-\infty`)

``x%y`` - остаток от деления

``divmod(x,y)`` - пара значений (``x//y``, ``x%y``)

.. code:: python

    print(7//3)
    print(7%3)
    print(divmod(7,3))


.. parsed-literal::

    2
    1
    (2, 1)


``int(a)`` - преобразование ``a`` в int

.. code:: python

    print(int(' 654'))
    print(int(-234.76))


.. parsed-literal::

    654
    -234


Числа с плавающей запятой (float)
---------------------------------

``float(a)`` - перевод ``a`` в float

.. code:: python

    print(float('3.4e2'))


.. parsed-literal::

    340.0


В некоторых задачах важно понимать как компьютер представляет числа. Наиболее частый тип используемых чисел для научного применения является `64-битный float <https://en.wikipedia.org/wiki/Double-precision_floating-point_format>`_.

.. image:: figs/t2_float64.svg

.. math:: (-1)^{b_{63}}\times(\overline{1.b_{51}b_{50}..b_0})_2\times 2^{(\overline{b_{62}b_{61}..b_{52}})_2 - 1023_{10}}

Рассмотрим число:

1 10000000101 0111001000000000000000000000000000000000000000000000

знак: :math:`(-1)^1 = -1`

степень: :math:`2^{10} + 2^2 +2^0=1029`;   :math:`2^{1029-1023} = 2^6`

мантисса:
:math:`1.0111001_2 = 10111001_2\times 2^{-7} = (2^7 + 2^5+2^4 +2^3 +2^0)\times2^{-7} = 185\times2^{-7}`

число: :math:`-185\times 2^{-7} \times 2^6 = -185\times 2^{-1} = - 92.5`

Необходимо помнить, что такое представление чисел в памяти обладает ограниченной точностью. Если ``a`` много больше ``b``, то ``b`` может оказаться меньше погрешности, с которой задается ``a``, и быть с точки зрения ``a`` нулем.

.. code:: python

    a = 1.7e308
    b = a - 2.5
    print(a==b)


.. parsed-literal::
 
    True

Машинное :math:`\epsilon` - минимальное число, при сложении которого с
единицей результат будет отличаться от единицы:
:math:`1+\epsilon \neq 1`

Округление же в таком случае происходит до ближайшего четного разряда
(т.е. по правилу :math:`2.5\approx2`, :math:`3.5\approx4`)

Все это может приводить к ошибке
:math:`-1+\left(1+\frac{\epsilon}{2}\right)\neq\left(-1+1\right)+\frac{\epsilon}{2}`


.. warning:: Будьте внимательны суммируя числа разного порядка. 64-битный float имеет свои ограничения, связанные со способом его кодирования


float поддерживает специальные 'не числа' ``nan`` и ``inf``.

.. code:: python

    n = float('nan')
    print(n)
    print(n>=0)
    print(n<=0)
    print(n==n)


.. parsed-literal::

    nan
    False
    False
    False


.. code:: python

    infty = float('inf')
    print(infty)
    print(infty>1.7e308)
    print(-1.7e308-1e307)


.. parsed-literal::

    inf
    True
    -inf




Комплексные числа (complex)
---------------------------

стандартная запись: ``C = Re + Imj``,  (``с = 1.5 - 0.3j``)

``c.conjugate()`` - комплексное сопряжение ``c``

``c.real`` - действительная часть ``c``

``c.imag`` - мнимая часть ``c``

``complex(Re, Im)`` - перевод пары чисел ``Re, Im`` в одно число типа complex

В остальном к комплексным числам применимы те же арифметические операции, что и для остальных чисел. Выполняются они в соответствии с алгеброй комплексных чисел.

.. code:: python

    complex(1.5, -0.3)




.. parsed-literal::

    (1.5-0.3j)



.. code:: python

    c = 1/2**0.5 * (1+ 1j)
    print(c)
    
    c_ = c.conjugate()
    print(c_, c*c_)
    print(c.real, c_.imag)


.. parsed-literal::

    (0.7071067811865475+0.7071067811865475j)
    (0.7071067811865475-0.7071067811865475j) (0.9999999999999998+0j)
    0.7071067811865475 -0.7071067811865475



Модуль math
===========
Модуль math является встроенным модулем python для простейших математических операций. Описание модуля и его функций можно найти в `документации модуля math <https://docs.python.org/3/library/math.html>`_. На практике, удобнее и эффективнее использовать специализированный модуль numerical python (NumPy). Далее в курсе мы будем пользоваться именно им.  

Для использования любого модуля или отдельной функции, метода, или константы из него, необоходимо сначала его подключить к вашему скрипту (импортировать). Рассмотрим несколько примеров подключения и использования модуля math (рассчитываем :math:`\sin (\frac{\pi}{4})`):

.. code-block:: python

    import math     
    y = math.sin(math.pi/4)   # любая другая функция модуля вызывается схожим способом
    #    ^    ^
    #    |    |
    #    | название функции в модуле
    #    |
    # название модуля

Внутри вашего скрипта любому сторонyему модулю можно дать свое локальное имя (часто используется в случае длинного названия модуля)

.. code-block:: python

    import math as m        # в дальнейшем к модулю math можно обращаться через m
    y = m.sin(m.pi/4)       # тоже что в предыдущем примере math.sin(math.pi/4)
    
Помимо этого, можно подгрузить отдельные объекты из модуля

.. code-block:: python

    from math import sin, pi
    y = sin(pi/4)

или загрузить модуль полностью

.. code-block:: python

    from math import *
    y = sin(pi/4)

В первом случае имена ``sin`` и ``pi`` , которые были определены внутри модуля math, доступны в вашей программе, так, как будто вы определили их сами. Во втором случае в вашей программе доступны все имена модуля math, как будто он стал частью вашей программы.

.. note:: В качестве подключаемого модуля может быть ваш собственный файл (удобно использовать для разбиения фунционала в случае больших проектов или в качестве вашего личного модуля с уже написанными наиболее часто используемыми алгоритмами). Подключение файла :file:`my_super_module.py` лежащего в той же папке, где и основной скрипт, происходит аналогично другим модулям ``import my_super_module``

Списки (list)
=============

Подробное описание в `документации <https://docs.python.org/3.8/library/stdtypes.html#sequence-types-list-tuple-range>`_.

Создание пустого списка:

.. code:: python

    l = []
    print(l)


.. parsed-literal::

    []


Создание списка с однообразным содержимым

.. code:: python

    l = [None for i in range(4)]
    print(l)


.. parsed-literal::

    [None, None, None, None]

Данное выражение называется генератором списка. Читать его нужно как "сделай ``None`` для ``i`` в диапазоне от ``0`` до ``4`` (не включительно)", т.е.: ``None`` (``i=0``), ``None`` (``i=1``), ``None`` (``i=2``), ``None`` (``i=3``). Эту последовательность мы преобразуем в список и получаем ``[None, None, None, None]``.

.. code:: python

    l = [['x', 'y', 'z'] for i in range(5)]
    print(l)


.. parsed-literal::

    [['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z']]


Аналогично, но вместо ``None`` здесь записывался список ``['x', 'y', 'z']``.

Обращения к элементам списка
----------------------------

.. code:: python

    l = [1, 2, [3, 4], 5]
    print(l)
    print(l[3], l[-1], l[0], l[-4])


.. parsed-literal::

    [1, 2, [3, 4], 5]
    5 5 1 1


.. code:: python

    print(l[2])
    print(l[2][0])


.. parsed-literal::

    [3, 4]
    3

Здесь элемент списка ``l`` ``l[2]`` сам является списком и выражение ``l[2][0]`` - обращение к элементу ``0`` списка ``l[2]``.

Срезы списков
-------------
 
Из списков можно легко генерировать списки меньшего размера

.. code:: python

    a = list(range(10))
    print(a)
    print(a[2:6])
    print(a[2:])


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [2, 3, 4, 5]
    [2, 3, 4, 5, 6, 7, 8, 9]

Левая граница включается в срез, а правая - нет!

Можно делать срезы с определенным шагом

.. code:: python

    print(a[1:8:2])
    print(a[::3])
    print(a[-2:0:-1])


.. parsed-literal::

    [1, 3, 5, 7]
    [0, 3, 6, 9]
    [8, 7, 6, 5, 4, 3, 2, 1]


Свойства списков
----------------

``len(a)`` - длина ``a``

``min(a)`` - минимальный элемент ``a``

``max(s)`` - максимальный элемент ``a``

.. code:: python

    a = [1, 2, 3, -54, 2, 2]
    print(len(a))
    print(max(a))
    print(min(a))


.. parsed-literal::

    6
    3
    -54


``a.index(x)`` - индекс первого вхождения ``x`` в ``a``

``a.count(x)`` - сколько раз ``x`` встречается в ``a``

.. code:: python

    print(a.index(2))
    print(a.count(2))


.. parsed-literal::

    1
    3


Списки поддерживают некоторые логические операции

.. code:: python

    l = [1, 2, [3, 4], 5]
    print(1 in l)
    print(3 in l)
    print(3 in l[2])


.. parsed-literal::

    True
    False
    True


Некоторые операции со списками
------------------------------

Простейшие и самые необходимые операции

``a[i] = x`` - заменить элемент ``a[i]`` на ``x``

``a[i:j] = x`` - тоже, но для среза ``a[i:j]`` (``x`` должно быть
итерируемым)

.. code:: python

    a = list(range(6))
    print(a)
    a[5] = 6
    print(a)
    a[5:6] = [6, 7, 8]
    print(a)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5]
    [0, 1, 2, 3, 4, 6]
    [0, 1, 2, 3, 4, 6, 7, 8]


``a.append(x)`` - добавить элемент ``x`` в конец ``a``

``a.pop(i)`` - удалить элемент ``a[i]``

.. code:: python

    a.append(9)
    print(a)
    a.pop(1)
    print(a)


.. parsed-literal::

    [0, 1, 2, 3, 4, 6, 7, 8, 9]
    [0, 2, 3, 4, 6, 7, 8, 9]


Списки поддерживают операции объединения и мультипликации

.. code:: python

    a = [1, 2, 3]
    b = ['a', 'b', 'c']
    print(a + b)
    print(a * 3)


.. warning:: При присваивание списка, получаемый объект является тем же самым списком. Изменяя его, вы изменяете исходный список

    .. code:: python

        a = [1, 2, 3]
        b = a
        b[0] = 0
        print(a)

    .. parsed-literal::

        [0, 2, 3]


    Этого можно избежать поэлементным копированием 

    .. code:: python

        a = [1, 2, 3]
        b = a[:]
        b[0] = 0
        print(a)


    .. parsed-literal::

        [1, 2, 3]

Задачи
===========
#. Выведите все числа от 0 до 100 делящиеся на введенное число.

#. Напишите программу для нахождения значения машинного эпсилон, прибавляя к единице :math:`2^{-1}`, :math:`2^{-2}`,  :math:`2^{-3}` и т.д. 

#. Сравните друг с другом четыре машинных числа: :math:`1`, :math:`1+ \frac{\epsilon}{2}`, :math:`1+\epsilon`, :math:`1+\epsilon+ \frac{\epsilon}{2}`, объясните результат. То же для чисел :math:`1+\epsilon+ \frac{\epsilon}{2}` и :math:`1+ \frac{\epsilon}{2} +\epsilon`.

#. Просуммируйте ряд 1/n, где n изменяется от 1 до миллиона, и от миллиона до 1 (т.е. ряды :math:`\frac{1}{1}+\frac{1}{2}+...+\frac{1}{10^6}` и :math:`\frac{1}{10^6}+\frac{1}{999999}+...+ \frac{1}{1}`). Сравните результат. В чем причина различия, и какая из сумм точнее?

#. Напишите программу, которая считывает комплексное число из консоли (по отдельности действительную и мнимую часть), находит комплекно сопряженное число, и нормирует (:math:`|c|^2=1`).

#. Создайте список с именем L, который содержит четыре строки или числа (например, ``L = [0,1,2,3]``). Что произойдет, если попытаться получить доступ к элементу, индекс которого выходит за пределы списка (например, ``L[4]``)? Что произойдет, если попытаться извлечь срез, выходящий за пределы списка (например, ``L[-1000:100]``)? Как отреагирует интерпретатор на попытку извлечь последовательность в обратном порядке, когда нижняя граница больше верхней (например, ``L[3:1]``)? (Попробуйте выполнить операцию присваивания такому срезу (``L[3:1] = ['9']``) и посмотреть, куда будет помещено значение) Как вы думаете, это то же самое явление, что и при попытке извлечь срез, выходящий за пределы списка? Создайте другой список ``L`` с четырьмя элементами и присвойте одному из элементов пустой список (например, ``L[2] = []``). Что произошло? Затем присвойте пустой список срезу (``L[2:3] = []``). Что случилось на этот раз? Не забывайте, что операция присваивания срезу сначала удаляет срез, а затем вставляет новое значение в заданную позицию. Инструкция ``del`` удаляет элемент с указанным смещением, ключом, атрибутом или именем. Используйте ее для удаления элемента вашего списка (например, ``del L[0]``). Что произойдет, если попробовать удалить целый срез (``del L[1:]``)? Что произойдет, если срезу присвоить объект, который не является последовательностью (``L[1:2] = 1``)?

#. Из списка, задаваеммого в начале скрипта (просто в виде ``a=[6, 3, 'h',...]``) выведите каждый третий элемент.

#. Геометрию молекулы можно задать в виде списка ``[['Element',x,y,z], ...]``. Для молекулы воды такой словарь представлен ниже (координаты в ангстремах)

    .. code:: python

        water = [['O',  0.000, 0.000, 0.0],
                 ['H',  0.757, 0.586, 0.0],
                 ['H', -0.757, 0.586, 0.0]]

    Найдите положение центра масс, и момент инерции для молекулы воды. Постарайтесь решить задачу так, чтобы программа могла справиться с любым количеством атомов, и быстро дополнялась для учета бОльшего количества типов атомов.
    
    .. hint:: Используйте словарь для хранения масс для каждого типа атома. Ссылки на Википедию: `положение центра масс <https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80_%D0%BC%D0%B0%D1%81%D1%81#%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5>`_, `момент инерции <https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BC%D0%B5%D0%BD%D1%82_%D0%B8%D0%BD%D0%B5%D1%80%D1%86%D0%B8%D0%B8#%D0%9E%D1%81%D0%B5%D0%B2%D0%BE%D0%B9_%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82_%D0%B8%D0%BD%D0%B5%D1%80%D1%86%D0%B8%D0%B8>`_ 

#. Найдите собственные значения и собственные вектора матрицы :math:`2\times2` (матрицу задавайте в самом коде программы).

    .. hint:: Вспоминаем математику. В интернете куча статей с простыми примерами, например `эта <http://mathportal.net/index.php/vektornaya-algebra/sobstvennye-chisla-i-vektora-matrits-metody-ikh-nakhozhdeniya>`_.

#. После прочтения очередного файла, вы получили список следующего содержания:

    .. code:: python

        graph = [['name one',  'name two' ],
                 ['units one', 'units two'],
                 ['100.5439', '    23.321'],
                 ['100.6439', '    22.129'],
                 ['100.7440', '    22.974']]
    
    Преобразуте численные значения в два отдельных листа ``X`` и ``Y`` (должны содержать исключительно числа, имена и единицы можно вынести в отдельный словарь). 

#. Сгенерируйте равномерную сетку ``X1`` от 0 до :math:`2\pi` с шагом 0.1 (0, 0.1, 0.2, ..., :math:`2\pi-0.1`, :math:`2\pi`). В отдельный список ``Y1`` сохраните значения ``sin(X1)``. Сгенерируйте **не** равномерную сетку ``X2`` от 0 до :math:`2\pi` с шагом :math:`\frac{0.01}{x+1}`. В отдельный список ``Y2`` сохраните значения ``sin(X2)``. Используя усреднение по среднему на шаг сетки, перевидите результат ``X2, Y2`` в ``X1, Y1``. 

#. Во многих случая со строками можно работать как со списками. Измените строку ``'spam'`` на ``'slam'`` используя только взятие среза и конкатенацию (сложение). Используя только индексирование и конкатенацию.





