.. _theme3:

=========================================
Числа и списки
=========================================
`Лекция в .ipynb формате <../../source/lectures/theme3.ipynb>`_

Числа
=======
В python существует три стандартных класса чисел: цлочисленные (int), числа с плавающей запятой (float) и комплексные числа (complex). Подробное описание спецификаций численных типов Python можно найти в `описании типов <https://docs.python.org/3.8/library/stdtypes.html?#numeric-types-int-float-complex>`_. 

Общие операции ``+``, ``-``, ``*``, ``/``, ``**`` (степень).

.. code:: python

    print(2+3)
    print(3/2)
    print(9**0.5)
    print(0**0)


.. parsed-literal::

    5
    1.5
    3.0
    1


Целые числа (int)
-----------------

``x//y`` - целочисленное деление (округление в сторону :math:`-\infty`)

``x%y`` - остаток от деления

``divmod(x,y)`` - пара значений (``x//y``, ``x%y``)

.. code:: python

    print(7//3)
    print(7%3)
    print(divmod(7,3))


.. parsed-literal::

    2
    1
    (2, 1)


``int(a)`` - преобразование ``a`` в int

.. code:: python

    print(int(' 654'))
    print(int(-234.76))


.. parsed-literal::

    654
    -234


Числа с плавающей запятой (float)
---------------------------------

``float(a)`` - перевод ``a`` в float

.. code:: python

    print(float('3.4e2'))


.. parsed-literal::

    340.0


В некоторых задачах важно понимать как компьютер представляет числа. Наиболее частый тип используемых чисел для научного применения является `64-битный float <https://en.wikipedia.org/wiki/Double-precision_floating-point_format>`_.

.. image:: figs/t2_float64.svg

.. math:: (-1)^{b_{63}}\times(\overline{1.b_{51}b_{50}..b_0})_2\times 2^{(\overline{b_{62}b_{61}..b_{52}})_2 - 1023_{10}}

Рассмотрим число:

1 10000000101 0111001000000000000000000000000000000000000000000000

знак: :math:`(-1)^1 = -1`

степень: $ 2^{10} + 2^2 +2^0=1029$;   :math:`2^{1029-1023} = 2^6`

мантисса:
:math:`1.0111001_2 = 10111001_2\times 2^{-7} = (2^7 + 2^5+2^4 +2^3 +2^0)\times2^{-7} = 185\times2^{-7}`

число: :math:`-185\times 2^{-7} \times 2^6 = -185\times 2^{-1} = - 92.5`

.. code:: python

    a = 1.7e308
    b = a - 2.5
    print(a==b)


.. parsed-literal::

    True

Машинное :math:`\epsilon` - минимальное число, при сложении которого с
единицей результат будет отличаться от единицы:
:math:`1+\epsilon \neq 1`

Округление же в таком случае происходит до ближайшего четного разряда
(т.е. по правилу :math:`2.5\approx2`, :math:`3.5\approx4`)

Все это может приводить к ошибке
:math:`-1+\left(1+\frac{\epsilon}{2}\right)\neq\left(-1+1\right)+\frac{\epsilon}{2}`


.. warning:: Будьте внимательны суммируя числа разного порядка. 64-битный float имеет свои ограничения, связанные со способом его кодирования


float поддерживает специальные 'не числа' ``nan`` и ``inf``.

.. code:: python

    n = float('nan')
    print(n)
    print(n>=0)
    print(n<=0)
    print(n==n)


.. parsed-literal::

    nan
    False
    False
    False


.. code:: python

    infty = float('inf')
    print(infty)
    print(infty>1.7e308)
    print(-1.7e308-1e307)


.. parsed-literal::

    inf
    True
    -inf




Комплексные числа (complex)
---------------------------

стандартная запись: ``C = Re + Imj``, ``с = 1.5 - 0.3j``

``c.conjugate()`` - комплексное сопряжение ``c``

``c.real`` - действительная часть

``c.imag`` - мнимая часть

``complex(Re, Im)`` - перевод ``Re, Im`` в complex

.. code:: python

    complex(1.5, -0.3)




.. parsed-literal::

    (1.5-0.3j)



.. code:: python

    c = 1/2**0.5 * (1+ 1j)
    print(c)
    
    c_ = c.conjugate()
    print(c_, c*c_)
    print(c.real, c_.imag)


.. parsed-literal::

    (0.7071067811865475+0.7071067811865475j)
    (0.7071067811865475-0.7071067811865475j) (0.9999999999999998+0j)
    0.7071067811865475 -0.7071067811865475



Модуль math
===========
Модуль math является встроенным модулем python для простейших математических операций. Описание модуля и его функций можно найти в `документации модуля math <https://docs.python.org/3/library/math.html>`_. На практике, удобнее и эффективнее использовать специализированный модуль numerical python (NumPy). При дальнейшем изучении курса мы будем пользоваться именно им.  

Для использования любого модуля или отдкльной функции, метода, или константы из него, необоходимо сначала его подключить к вашему скрипту. Рассмотрим несколько примеров подключения и использования модуля math (рассчитываем :math:`\sin (\frac{\pi}{4})`):

.. code-block:: python

    import math     
    y = math.sin(math.pi/4)   # любая другая функция модуля вызывается схожим способом
    #    ^    ^
    #    |    |
    #    | название функции в модуле
    #    |
    # название модуля

Внутри вашего скрипта любому сторонyему модулю можно дать свое локальное имя (часто используется в случае длинного названия модуля)

.. code-block:: python

    import math as m        # в дальнейшем к модулю math можно обращаться через m
    y = m.sin(m.pi/4)       # тоже что в предыдущем примере math.sin(math.pi/4)
    
Помимо этого, можно подгрузить отдельные объекты из модуля

.. code-block:: python

    from math import sin, pi
    y = sin(pi/4)

или загрузить модуль полностью

.. code-block:: python

    from math import *
    y = sin(pi/4)
 
.. note:: В качестве подключаемого модуля может быть ваш собственный файл (удобно использовать для разбиения фунционала в случае больших проектов или в качестве вашего личного модуля с уже написанными наиболее частоиспользуемыми алгоритмами. Подключение файла :file:`my_super_module.py` лежащего в той же папке, где и основной скрипт, происходит аналогично другим модулям ``import my_super_module``

Списки
======

Подробное описание в `документации <https://docs.python.org/3.8/library/stdtypes.html#sequence-types-list-tuple-range>`_.

Создание пустого списка:

.. code:: python

    l = []
    print(l)


.. parsed-literal::

    []


Создание списка с однообразным содержимым

.. code:: python

    l = [None for i in range(4)]
    print(l)


.. parsed-literal::

    [None, None, None, None]


.. code:: python

    l = [['x', 'y', 'z'] for i in range(5)]
    print(l)


.. parsed-literal::

    [['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z']]


Обращения к элементам списка
----------------------------

.. code:: python

    l = [1, 2, [3, 4], 5]
    print(l)
    print(l[3], l[-1], l[0], l[-4])


.. parsed-literal::

    [1, 2, [3, 4], 5]
    5 5 1 1


.. code:: python

    print(l[2])
    print(l[2][0])


.. parsed-literal::

    [3, 4]
    3


Срезы списков
-------------

Из списков можно легко генерировать списки меньшего размера

.. code:: python

    a = list(range(10))
    print(a)
    print(a[2:6])
    print(a[2:])


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [2, 3, 4, 5]
    [2, 3, 4, 5, 6, 7, 8, 9]


Можно делать срезы с определенным шагом

.. code:: python

    print(a[1:8:2])
    print(a[::3])
    print(a[-2:0:-1])


.. parsed-literal::

    [1, 3, 5, 7]
    [0, 3, 6, 9]
    [8, 7, 6, 5, 4, 3, 2, 1]


Свойства списков
----------------

``len(a)`` - длина ``a``

``min(a)`` - минимальный элемент ``a``

``max(s)`` - максимальный элемент ``a``

.. code:: python

    a = [1, 2, 3, -54, 2, 2]
    print(len(a))
    print(max(a))
    print(min(a))


.. parsed-literal::

    6
    3
    -54


``a.index(x)`` - индекс первого вхождения ``x`` в ``a``

``a.count(x)`` - сколько раз ``x`` встречается в ``a``

.. code:: python

    print(a.index(2))
    print(a.count(2))


.. parsed-literal::

    1
    3


Списки поддерживают некоторые логические операции

.. code:: python

    l = [1, 2, [3, 4], 5]
    print(1 in l)
    print(3 in l)
    print(3 in l[2])


.. parsed-literal::

    True
    False
    True


Некоторые операции со списками
------------------------------

Простейшие и самые необходимые операции

``a[i] = x`` - заменить элемент ``a[i]`` на ``x``

``a[i:j] = x`` - тоже, но для среза ``a[i:j]`` (``x`` должно быть
итерируемым)

.. code:: python

    a = list(range(6))
    print(a)
    a[5] = 6
    print(a)
    a[5:6] = [6, 7, 8]
    print(a)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5]
    [0, 1, 2, 3, 4, 6]
    [0, 1, 2, 3, 4, 6, 7, 8]


``a.append(x)`` - добавить элемент ``x`` в конец ``a``

``a.pop(i)`` - удалить элемент ``a[i]``

.. code:: python

    a.append(9)
    print(a)
    a.pop(1)
    print(a)


.. parsed-literal::

    [0, 1, 2, 3, 4, 6, 7, 8, 9]
    [0, 2, 3, 4, 6, 7, 8, 9]


Списки поддерживают операции объединения и мультипликации

.. code:: python

    a = [1, 2, 3]
    b = ['a', 'b', 'c']
    print(a + b)
    print(a * 3)


.. warning:: При присваивание списка, получаемый объект является тем же самым списком. Изменяя его, вы изменяете исходный список

    .. code:: python

        a = [1, 2, 3]
        b = a
        b[0] = 0
        print(a)

    .. parsed-literal::

        [0, 2, 3]


    Этого можно избежать поэлементным копированием 

    .. code:: python

        a = [1, 2, 3]
        b = a[:]
        b[0] = 0
        print(a)


    .. parsed-literal::

        [1, 2, 3]

Задачи
===========
#. Выведите все числа от 0 до 100 делящиеся на введенное число.

#. Напишите программу для нахождения значения машинного эпсилон, прибавляя к единице :math:`2^{-1}`, :math:`2^{-2}`,  :math:`2^{-3}` и т.д. 

#. Сравните друг с другом четыре машинных числа: :math:`1`, :math:`1+ \frac{\epsilon}{2}`, :math:`1+\epsilon`, :math:`1+\epsilon+ \frac{\epsilon}{2}`, объясните результат. То же для чисел :math:`1+\epsilon+ \frac{\epsilon}{2}` и :math:`1+ \frac{\epsilon}{2} +\epsilon`.

#. Просуммируйте ряд 1/n, где n изменяется от 1 до миллиона, и от миллиона до 1 (т.е. ряды :math:`\frac{1}{1}+\frac{1}{2}+...+\frac{1}{10^6}` и :math:`\frac{1}{10^6}+\frac{1}{999999}+...+ \frac{1}{1}`). Сравните результат. В чем причина различия, и какая из сумм точнее?

#. Напишите программу, которая считывает комплексное число из консоли (по отдельности действительную и мнимую часть), находит комплекно сопряженное число, и нормирует (:math:`|c|^2=1`).

#. Создайте список с именем L, который содержит четыре строки или числа (например, ``L = [0,1,2,3]``). Что произойдет, если попытаться получить доступ к элементу, индекс которого выходит за пределы списка (например, ``L[4]``)? Что произойдет, если попытаться извлечь срез, выходящий за пределы списка (например, ``L[-1000:100]``)? Как отреагирует интерпретатор на попытку извлечь последовательность в обратном порядке, когда нижняя граница больше верхней (например, ``L[3:1]``)? (Попробуйте выполнить операцию присваивания такому срезу (``L[3:1] = ['9']``) и посмотреть, куда будет помещено значение) Как вы думаете, это то же самое явление, что и при попытке извлечь срез, выходящий за пределы списка? Создайте другой список ``L`` с четырьмя элементами и присвойте одному из элементов пустой список (например, ``L[2] = []``). Что произошло? Затем присвойте пустой список срезу (``L[2:3] = []``). Что случилось на этот раз? Не забывайте, что операция присваивания срезу сначала удаляет срез, а затем вставляет новое значение в заданную позицию. Инструкция ``del`` удаляет элемент с указанным смещением, ключом, атрибутом или именем. Используйте ее для удаления элемента вашего списка (например, ``del L[0]``). Что произойдет, если попробовать удалить целый срез (``del L[1:]``)? Что произойдет, если срезу присвоить объект, который не является последовательностью (``L[1:2] = 1``)?

#. Из списка, задаваеммого в начале файла выведите каждый третий элемент.

#. Геометрию молекулы можно задать в виде списка ``[['Element',x,y,z], ...]``. Для молекулы воды такой словарь представлен ниже (координаты в ангстремах)

    .. code:: python

        water = [['O',  0.000, 0.000, 0.0],
                 ['H',  0.757, 0.586, 0.0],
                 ['H', -0.757, 0.586, 0.0]]

    Найдите положение центра масс, и момент инерции для молекулы воды. Постарайтесь решить задачу так, чтобы программа могла справиться с любым количеством атомов, и быстро дополнялась для учета бОльшего количества типов атомов.
    
    .. hint:: Используйте словарь для хранения масс для каждого типа атома. Ссылки на Википедию: `положение центра масс <https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80_%D0%BC%D0%B0%D1%81%D1%81#%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5>`_, `момент инерции <https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BC%D0%B5%D0%BD%D1%82_%D0%B8%D0%BD%D0%B5%D1%80%D1%86%D0%B8%D0%B8#%D0%9E%D1%81%D0%B5%D0%B2%D0%BE%D0%B9_%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82_%D0%B8%D0%BD%D0%B5%D1%80%D1%86%D0%B8%D0%B8>`_ 

#. Найдите собственные значения и собственные вектора матрицы :math:`2\times2` (матрицу задавайте в самом коде программы).

    .. hint:: Вспоминаем математику. В интернете куча статей с простыми примерами, например `эта <http://mathportal.net/index.php/vektornaya-algebra/sobstvennye-chisla-i-vektora-matrits-metody-ikh-nakhozhdeniya>`_.

#. После прочтения очередного файла, вы получили список следующего содержания:

    .. code:: python

        graph = [['name one',  'name two' ],
                 ['units one', 'units two'],
                 ['100.5439', '    23.321'],
                 ['100.6439', '    22.129'],
                 ['100.7440', '    22.974']]
    
    Преобразуте численные значения в два отдельных листа ``X`` и ``Y`` (должны содержать исключительно числа, имена и единицы можно вынести в отдельный словарь). 

#. Сгенерируйте равномерную сетку ``X1`` от 0 до :math:`2\pi` с шагом 0.1 (0, 0.1, 0.2, ..., :math:`2\pi-0.1`, :math:`2\pi`). В отдельный список ``Y1`` сохраните значения ``sin(X1)``. Сгенерируйте **не** равномерную сетку ``X2`` от 0 до :math:`2\pi` с шагом :math:`\frac{0.01}{x+1}`. В отдельный список ``Y2`` сохраните значения ``sin(X2)``. Используя усреднение по среднему на шаг сетки, перевидите результат ``X2, Y2`` в ``X1, Y1``. 

#. Во многих случая со строками можно работать как со списками. Измените строку ``'spam'`` на ``'slam'`` используя только взятие среза и конкатенацию (сложение). Используя только индексирование и конкатенацию.





